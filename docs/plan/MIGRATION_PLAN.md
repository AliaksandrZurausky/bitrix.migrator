# Bitrix Migrator — план миграции (Cloud → Box)

## 0. Цель и принципы
- Цель: разовая миграция данных из облачного Bitrix24 в коробочный Bitrix (CRM сущности + связи + таймлайн + задачи + файлы + пользователи + структура) без удаления данных в облаке.
- Основной принцип: миграция асинхронная, управляемая (start/pause/resume), не привязанная к сессии браузера.
- Основной принцип идемпотентности: повторный запуск после паузы/сбоя НЕ создаёт дублей, если элемент уже был перенесён мигратором и имеет `UF_CLOUD_ID`.

## 1. Источник данных (облако)
- Источник: REST API Bitrix24 через входящий webhook вида `https://<portal>/rest/<user>/<token>/...`.
- Получение структуры полей сущностей через методы `crm.*.fields` (например `crm.deal.fields`) для dry run и построения плана переноса.
- Для пользовательских полей (если потребуется точечное создание) ориентироваться на семейство методов `crm.*.userfield.*` (например `crm.deal.userfield.add`).
- Получение данных о пользователях через `user.get`, `user.search` для маппинга и миграции.
- Получение структуры отделов через `department.get`, `department.list` для полного переноса иерархии.

## 2. Сущности в MVP
Обязательные к переносу:
- Сделки
- Лиды
- Контакты
- Компании

Также требуется (как зависимости/содержимое):
- **Структура (отделы)** — перенос полной иерархии отделов и их параметров
- **Пользователи** — перенос сотрудников (с выбором в dry run), синхронизация полей
- Таймлайн CRM (максимально возможный перенос)
- Задачи, связанные с CRM сущностями (переносить «всё что можно», лучше отдельной финальной фазой)
- Файлы из:
  - таймлайна
  - задач
  - карточек элементов (если прикреплены)

## 3. Политики "конфликтов" и повторного запуска
### 3.1. "Чистая система"
- Предполагаем, что коробка чистая: если встречается сущность без `UF_CLOUD_ID`, мы её **не трогаем** (skip) и пишем в лог.

### 3.2. "Элемент уже переносился мигратором"
- Если в коробке найден объект с заполненным `UF_CLOUD_ID`, то это "повторный прогон", и поведение определяется настройкой перед запуском миграции:
  - `SKIP` (по умолчанию)
  - `UPDATE` (обновлять поля по данным из облака)
  - `DELETE_AND_RECREATE` (удалить и создать заново)
  - `DUPLICATE` (создать дубль, сохранив старый)
- Настройка задаётся **после dry run**, перед стартом миграции, и сохраняется в State HL-блоке.

## 4. Dry run (обязательный шаг перед миграцией)
Dry run выполняет:
- Проверку подключения к webhook и прав доступа.
- Сбор справочных данных (что доступно для переноса).
- Формирование "плана миграции" (по умолчанию включено всё).
- **Сбор информации о пользователях**: список всех сотрудников из облака, сравнение с уже имеющимися в коробке, выявление новых пользователей.
- **Сбор информации о структуре**: список отделов из облака, их иерархия, параметры.

### 4.1. Что должно быть доступно для выбора (в UI)
После dry run, до "Старт миграции" должно быть UI, где по умолчанию всё включено, но можно отключить:
- **Структура**: чекбокс "переносить отделы", выбор существующих отделов коробки (в случае если не мигрируем)
- **Пользователи**: 
  - список новых пользователей (найденных в облаке, но не в коробке)
  - чекбоксы для каждого — "мигрировать или пропустить"
  - опция "мигрировать всех найденных" / "пропустить всех"
  - указание группы по умолчанию для новых пользователей (при миграции)
- Сущности: сделки/лиды/контакты/компании
- Воронки/направления сделок + стадии (выбрать, какие переносим)
- Пользовательские поля по каждой сущности (чекбоксы исключения полей)
- Таймлайн: типы событий (если удастся классифицировать)
- Задачи: чекбоксы "переносить комментарии / чек-листы / файлы / …" (если API позволит)
- Файлы: чекбоксы "качать/загружать", ограничения по размеру/типам (опционально)

### 4.2. Результаты dry run (отчёт)
- **Информация о пользователях**:
  - сколько активных пользователей в облаке
  - сколько уже есть в коробке (по email/ФИО)
  - сколько новых пользователей предложено к миграции
  - список новых с их основными данными (ФИО, email, должность, отдел)
- **Информация о структуре**:
  - количество отделов в облаке
  - глубина иерархии
  - наличие отделов с тем же названием в коробке
- Количество сущностей к переносу по типам.
- Найденные воронки/стадии сделок (и возможность выбрать какие переносить).
- Список пользовательских полей по каждой сущности (и возможность снять галочки).
- Оценка по файлам (кол-во, примерные объёмы если возможно).
- Отчёт по пользователям (для CRM сущностей):
  - сколько пользователей нашли однозначно
  - сколько "не нашли/неоднозначно" → будет создана заглушка

## 5. Перенос структуры (отделы)
### 5.1. Получение структуры из облака
- Получаем полный список отделов через `department.list` или `department.get`.
- Сохраняем иерархию (parent_id).
- По каждому отделу собираем:
  - `ID` (cloudDepartmentId)
  - `NAME`
  - `PARENT_ID` (если есть)
  - `DESCRIPTION` (если заполнено)
  - `UF_*` пользовательские поля (если есть)

### 5.2. Перенос в коробку
- Если в плане включено "переносить отделы":
  - создаём отделы в коробке через `CGroup::Add` (или аналог в зависимости от версии)
  - соблюдаем иерархию (сначала родители, потом дочки)
  - заполняем пользовательские поля, если определены
  - для каждого созданного отдела в Map сохраняем: cloudDepartmentId → localDepartmentId
- Если НЕ переносим отделы:
  - при привязке пользователей/сущностей используем дефолтный отдел коробки или отдел, указанный в настройках мигратора

### 5.3. Уникальность и конфликты
- Если отдел с таким названием уже есть в коробке (и он был там до миграции):
  - логируем это как WARNING
  - используем существующий отдел (не создаём дубль)
  - добавляем в Map маппинг: cloudDepartmentId → localDepartmentId
- Дедупликацию по названию можно контролировать через опцию в плане миграции: "переиспользовать существующие отделы" / "создавать новые"

## 6. Перенос пользователей
### 6.1. Маппинг и выявление новых
- В облаке: получаем список всех пользователей через `user.get` (с фильтром по статусу, если нужны только активные).
- В коробке: ищем соответствие:
  1) по email (точно, учитывая регистр)
  2) если не найден — по имени+фамилии (нечёткий поиск)
  3) если не найден — пользователь считается **новым**
- Результат: три группы:
  - "найдены точно" — маппируем, не переносим
  - "найдены неоднозначно" — логируем WARNING, ручная проверка в админке
  - "новые" — предлагаем для миграции в dry run

### 6.2. Выбор пользователей для миграции (в UI после dry run)
- Показываем список новых пользователей с полями:
  - ФИО
  - Email
  - Должность
  - Отдел (из облака)
  - Активный/неактивный
- Для каждого пользователя — чекбокс "мигрировать"
- Опции массового выбора: "мигрировать всех", "пропустить всех"
- Сохраняем выбор в State перед стартом миграции

### 6.3. Создание пользователя в коробке
Для каждого выбранного пользователя:
- Используем `CUser::Add` или REST API `user.add`
- Заполняем поля:
  - `NAME` (из облака)
  - `LAST_NAME` (из облака)
  - `EMAIL` (из облака)
  - `LOGIN` (из облака или генерируем, если недоступен)
  - `ACTIVE` (соответствует облаку; если выключен в облаке — выключаем и в коробке)
  - `PERSONAL_PHONE`, `PERSONAL_MOBILE`, `PERSONAL_PHOTO` (если заполнены в облаке)
  - `WORK_PHONE`, `WORK_POSITION`, `UF_*` (по доступным полям)
- Привязываем к отделу:
  - если отдел перенесён в коробку → используем localDepartmentId из Map
  - иначе → используем дефолтный отдел или отдел из настроек
- **Не отправляем** почтовые уведомления о регистрации (флаг `SKIP_SEND_NOTIFICATION` или эквивалент)
- Сохраняем маппинг в Map: cloudUserId → localUserId

### 6.4. Пользователи без email
- Если email в облаке не заполнен:
  - генерируем уникальный email: `migrator_user_<cloud_id>@invalid.local`
  - логируем WARNING с ФИО пользователя
  - создаём пользователя с генерированным email

### 6.5. Специальные пользователи
- Если в облаке есть "служебные" пользователи (система, робот, etc):
  - по умолчанию НЕ включаем их в список для миграции
  - но можно вручную выбрать в UI, если нужно

## 7. Пользователи (маппинг и заглушки в CRM)
### 7.1. Поиск пользователей для привязки к CRM сущностям
- Для каждого поля типа "пользователь" в сущности (например `ASSIGNED_BY_ID`):
  - если это cloudUserId, ищем localUserId в Map
  - если найдено — используем local ID
  - если не найдено:
    - если пользователь был отклонен при миграции → используем дефолтного пользователя (из настроек или текущего админа)
    - логируем WARNING

### 7.2. Создание "уволенного" пользователя-заглушки (только если не было миграции пользователей)
- Этот механизм используется **только** если **не** мигрируем пользователей (т.е. опция отключена в плане).
- Если пользователя не нашли и это cloudUserId, который не был перенесён:
  - создаём "заглушку" — неактивного пользователя в коробке
  - пользователь должен быть "уволенным" (неактивным): `ACTIVE = 'N'`
  - пользователь должен быть в дефолтных группах "как у обычного сотрудника" (берём группы из настроек мигратора)
  - EMAIL/LOGIN берём из облака; если email недоступен — генерируем уникальный email (`migrator_ghost_<n>@invalid.local`)
  - **не отправляем** почтовых уведомлений о регистрации
  - отдел не указываем (попадёт в первый по умолчанию — далее руками можно переместить)
  - сохраняем маппинг: cloudUserId → localUserId (заглушки)

## 8. Хранилище данных (HL-блоки)
Создаём минимум 5 HL-блоков:

### 8.1. MigratorState (состояние миграции)
Назначение:
- хранить настройки подключения (кроме секрета), выбранные чекбоксы плана, текущую фазу, прогресс, флаг pause, режимы повторного прогона и т.п.

Пример полей:
- UF_STATUS: NEW / DRY_RUN_DONE / RUNNING / PAUSED / FINISHED / ERROR
- UF_CURRENT_PHASE: string
- UF_PAUSE_FLAG: boolean
- UF_SETTINGS_JSON: string (или text) — сериализованный план/настройки (включает: какие пользователи мигрируются, переносится ли структура, и т.д.)
- UF_LAST_ERROR: text
- UF_STARTED_AT, UF_UPDATED_AT

### 8.2. MigratorQueue (очередь работ)
Назначение:
- разложить миграцию на атомарные задачи, чтобы агент мог шагать, продолжать после падений, и было видно прогресс.

Пример полей:
- UF_ENTITY_TYPE: department / user / deal / lead / contact / company / task / file / ...
- UF_CLOUD_ID: int/string
- UF_LOCAL_ID: int (если уже создан)
- UF_STATUS: NEW / IN_PROGRESS / DONE / ERROR / SKIPPED
- UF_RETRIES: int
- UF_LAST_ERROR: text
- UF_PRIORITY: int
- UF_DEPENDS_ON: string (опционально: зависимости)
- UF_UPDATED_AT

### 8.3. MigratorMap (маппинг идентификаторов)
Назначение:
- хранить соответствие cloud → local по сущностям, пользователям, файлам, отделам и т.д.

Пример полей:
- UF_ENTITY_TYPE: department / user / deal / lead / contact / company / file / ...
- UF_CLOUD_ID
- UF_LOCAL_ID
- UF_CLOUD_URL (опционально)
- UF_META_JSON (опционально)

### 8.4. MigratorLog (журнал)
Назначение:
- понятные логи для админа и разработчика.

Пример полей:
- UF_LEVEL: INFO/WARN/ERROR/DEBUG
- UF_MESSAGE: text
- UF_CONTEXT: string (phase/entity/id)
- UF_PAYLOAD: text/json (безопасно, без секретов)
- UF_CREATED_AT

### 8.5. MigratorDryRunResult (результаты last dry run)
Назначение:
- сохранять результаты последнего dry run для отображения в UI и для базы выбора при формировании плана.

Пример полей:
- UF_DEPARTMENTS_COUNT: int
- UF_USERS_COUNT: int
- UF_USERS_NEW_COUNT: int
- UF_USERS_NEW_LIST: text/json (список новых пользователей с их данными)
- UF_DEALS_COUNT: int
- UF_LEADS_COUNT: int
- UF_CONTACTS_COUNT: int
- UF_COMPANIES_COUNT: int
- UF_PIPELINES: text/json (список воронок)
- UF_CUSTOM_FIELDS: text/json (список пользовательских полей)
- UF_EXECUTED_AT
- UF_WEBHOOK_STATUS: OK / ERROR
- UF_WEBHOOK_ERROR_MSG: text (если ошибка)

## 9. Стратегия по файлам (коробка)
- Все файлы сначала выгружаются в папку на **общем диске** (одна корневая папка миграции).
- Копии файлов допустимы (дедупликацию можно сделать позже).
- Структура хранения (базовая):
  - `Migrator/Deals/<cloudDealId>/...`
  - `Migrator/Leads/<cloudLeadId>/...`
  - `Migrator/Contacts/<cloudContactId>/...`
  - `Migrator/Companies/<cloudCompanyId>/...`
  - `Migrator/Tasks/<cloudTaskId>/...`

## 10. Ссылки и cloud_id в коробке
Для каждой переносимой сущности создаём (если отсутствуют) системные пользовательские поля:
- `UF_CLOUD_ID` (число/строка)
- `UF_CLOUD_URL` (строка)

Далее все связи строим не по "сырым ID из облака", а через Map:
- если поле "привязка к компании" в сделке содержит cloudCompanyId → ищем localCompanyId по UF_CLOUD_ID/Map и ставим local ID.

## 11. Очерёдность (pipeline) миграции
Фазы (с возможностью паузы между шагами):
1) Dry run: сбор структуры, пользователей, CRM данных и формирование плана (без записи данных, кроме результатов в HL-блок)
2) Подготовка коробки:
   - создание пользовательских полей (по выбранному плану)
   - создание воронок/стадий сделок (по выбранному плану)
3) Перенос структуры (отделы):
   - если включено в плане — создание отделов с соблюдением иерархии
   - маппинг в MigratorMap
4) Перенос пользователей:
   - если включено в плане — создание выбранных пользователей
   - маппинг в MigratorMap
5) Перенос справочников/зависимостей (если всплывут)
6) Перенос базовых сущностей:
   - компании
   - контакты (с привязкой к компаниям и пользователям)
   - лиды (с привязкой к пользователям)
   - сделки (с привязками к контактам/компаниям/лидам/пользователям, где применимо)
7) Перенос таймлайна (насколько возможно)
8) Перенос задач, связанных с CRM сущностями (в конце, чтобы привязки уже были)
9) Перенос/прикрепление файлов (если не сделали в процессе сущностей/таймлайна/задач)
10) Финализация: отчёт, статистика, список проблем (пользователи/файлы/ошибки)

## 12. Исполнение (агент) и управление
- Выполнение через агент:
  - агент берёт пачку задач из Queue (с учётом приоритета и зависимостей)
  - обрабатывает шаг
  - фиксирует прогресс в State/Queue/Map/Log
  - проверяет флаг PAUSE → завершает текущий шаг и выходит
- Управление:
  - Start: создаёт план очереди (с учётом выбранных пользователей и структуры) и включает RUNNING
  - Pause: выставляет флаг PAUSE (graceful stop)
  - Resume: снимает флаг PAUSE и продолжает по чекпойнту

## 13. UI админки (одна страница с табами)
Одна страница модуля в стиле админки Битрикса, табы:
- **Подключение** (webhook, проверки, кнопка Dry run)
- **Dry run** (отчёт с информацией о структуре/пользователях/CRM, кнопка "Сформировать план")
- **План миграции**:
  - Структура: чекбокс "переносить отделы", выбор дефолтного отдела (если не мигрируем)
  - Пользователи: список новых с чекбоксами, "выбрать всех" / "пропустить всех", выбор группы по умолчанию
  - CRM сущности: чекбоксы "что переносим"
  - Воронки/стадии сделок: выбор
  - Исключения полей по сущностям
  - Политика повторного прогона по UF_CLOUD_ID
  - Кнопка "Запустить миграцию"
- **Миграция** (старт/пауза/продолжить, прогресс по фазам, счётчики, статус каждой фазы)
- **Логи** (фильтры уровней, экспорт, очистка)

## 14. Открытые вопросы (фиксируем заранее)
- Полный перечень типов событий таймлайна, которые реально можно перенести через REST API облака
- Как обрабатывать файлы, привязанные через CRM API (нужны ли дополнительные права на скачивание)
- Лимиты на количество одновременных запросов к облаку (throttling)
- Минимальная версия коробки, поддерживающая все используемые API методы
- Необходимость поддержки шифрования секретов в HL-блоках (webhook token)
