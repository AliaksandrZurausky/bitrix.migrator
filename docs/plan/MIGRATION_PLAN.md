# Bitrix Migrator — план миграции (Cloud → Box) — ОБНОВЛЕННЫЙ

## 0. Цель и принципы
- Цель: разовая миграция данных из облачного Bitrix24 в коробочный Bitrix (CRM сущности + связи + таймлайн + задачи + рабочие группы + пользователи + структура + диск) без удаления данных в облаке.
- Основной принцип: миграция асинхронная, управляемая (start/pause/resume), не привязанная к сессии браузера.
- Основной принцип идемпотентности: повторный запуск после паузы/сбоя НЕ создаёт дублей, если элемент уже был перенесён мигратором и имеет `UF_CLOUD_ID`.

## 1. Источник данных (облако)
- Источник: REST API Bitrix24 через входящий webhook вида `https://<portal>/rest/<user>/<token>/...`.
- Получение структуры полей сущностей через методы `crm.*.fields` (например `crm.deal.fields`) для dry run и построения плана переноса.
- Для пользовательских полей (если потребуется точечное создание) ориентироваться на семейство методов `crm.*.userfield.*` (например `crm.deal.userfield.add`).
- Получение данных о пользователях через `user.get`, `user.search` для маппинга и миграции.
- Получение структуры отделов через `department.get`, `department.list` для полного переноса иерархии.
- Получение рабочих групп через `socialnetwork.api.workgroup.list`, `sonet_group.user.list` для миграции проектов/групп.
- Получение воронок через `crm.dealcategory.list` и стадий через методы категорий.

## 2. Сущности в MVP
Обязательные к переносу:
- Сделки
- Лиды
- Контакты
- Компании

Также требуется (как зависимости/содержимое):
- **Структура (отделы)** — перенос полной иерархии отделов и их параметров
- **Пользователи** — перенос сотрудников (с выбором в dry run), синхронизация полей
- **Рабочие группы (Workgroups/Проекты)** — перенос групп, их членов, иерархии
- **Диск (Disk)** — перенос **структуры + файлов** (права/шаринг не переносим)
- **Воронки и стадии сделок** — перенос структуры воронок и маппинг стадий
- **Связи между сущностями** — привязки между контактами, лидами, сделками, компаниями
- Таймлайн CRM (максимально возможный перенос)
- Задачи, связанные с CRM сущностями и workgroups (переносить «всё что можно», лучше отдельной финальной фазой)
- Файлы из:
  - таймлайна
  - задач
  - карточек элементов (если прикреплены)

## 3. Политики "конфликтов" и повторного запуска
### 3.1. "Чистая система"
- Предполагаем, что коробка чистая: если встречается сущность без `UF_CLOUD_ID`, мы её **не трогаем** (skip) и пишем в лог.

### 3.2. "Элемент уже переносился мигратором"
- Если в коробке найден объект с заполненным `UF_CLOUD_ID`, то это "повторный прогон", и поведение определяется настройкой перед запуском миграции:
  - `SKIP` (по умолчанию)
  - `UPDATE` (обновлять поля по данным из облака)
  - `DELETE_AND_RECREATE` (удалить и создать заново)
  - `DUPLICATE` (создать дубль, сохранив старый)
- Настройка задаётся **после dry run**, перед стартом миграции, и сохраняется в State HL-блоке.

## 4. Dry run (обязательный шаг перед миграцией)
Dry run выполняет:
- Проверку подключения к webhook и прав доступа.
- Сбор справочных данных (что доступно для переноса).
- Формирование "плана миграции" (по умолчанию включено всё).
- **Сбор информации о пользователях**: список всех сотрудников из облака, сравнение с уже имеющимися в коробке, выявление новых пользователей.
- **Сбор информации о структуре**: список отделов из облака, их иерархия, параметры.
- **Сбор информации о рабочих группах**: список групп, их типы (public/private/secret), иерархия, члены.
- **Сбор информации о диске**: режимы переноса, оценка количества папок/файлов и примерных объёмов (если возможно).
- **Сбор информации о воронках**: список воронок сделок и стадии в каждой воронке.

### 4.1. Что должно быть доступно для выбора (в UI)
После dry run, до "Старт миграции" должно быть UI, где по умолчанию всё включено, но можно отключить:
- **Структура**: чекбокс "переносить отделы", выбор существующих отделов коробки (в случае если не мигрируем)
- **Пользователи**: 
  - список новых пользователей (найденных в облаке, но не в коробке)
  - чекбоксы для каждого — "мигрировать или пропустить"
  - опция "мигрировать всех найденных" / "пропустить всех"
  - указание группы по умолчанию для новых пользователей (при миграции)
- **Рабочие группы**:
  - чекбокс "переносить рабочие группы"
  - опция "переносить иерархию групп"
  - опция "переносить права доступа" (опционально, может быть сложно)
- **Диск (Disk)**:
  - режим: `FULL_DISK` / `ATTACHMENTS_ONLY` / `NONE`
  - ограничения по размеру/типам (опционально)
- **Воронки**:
  - список найденных воронок с чекбоксами
  - опция "переносить все воронки" / "пропустить все"
  - для каждой воронки — опция выбора стадий
- Сущности: сделки/лиды/контакты/компании
- Пользовательские поля по каждой сущности (чекбоксы исключения полей)
- Таймлайн: типы событий (если удастся классифицировать)
- Задачи: чекбоксы "переносить комментарии / чек-листы / файлы / …" (если API позволит)
- Файлы: чекбоксы "качать/загружать" (для вложений; для FULL_DISK используется режим Диска)

### 4.2. Результаты dry run (отчёт)
- **Информация о пользователях**:
  - сколько активных пользователей в облаке
  - сколько уже есть в коробке (по email/ФИО)
  - сколько новых пользователей предложено к миграции
  - список новых с их основными данными (ФИО, email, должность, отдел)
- **Информация о структуре**:
  - количество отделов в облаке
  - глубина иерархии
  - наличие отделов с тем же названием в коробке
- **Информация о рабочих группах**:
  - количество групп в облаке по типам (public/private/secret)
  - глубина иерархии групп
  - количество членов в каждой группе
- **Информация о диске**:
  - оценка количества папок/файлов (если возможно)
  - оценка примерного объёма (если возможно)
- **Информация о воронках**:
  - список воронок сделок
  - стадии в каждой воронке
  - количество сделок в каждой стадии (для оценки объёма)
- Количество сущностей к переносу по типам.
- Список пользовательских полей по каждой сущности (и возможность снять галочки).
- Оценка по файлам (кол-во, примерные объёмы если возможно).
- Отчёт по пользователям (для CRM сущностей):
  - сколько пользователей нашли однозначно
  - сколько "не нашли/неоднозначно" → будет создана заглушка

## 5. Перенос структуры (отделы)
### 5.1. Получение структуры из облака
- Получаем полный список отделов через `department.list` или `department.get`.
- Сохраняем иерархию (parent_id).
- По каждому отделу собираем:
  - `ID` (cloudDepartmentId)
  - `NAME`
  - `PARENT_ID` (если есть)
  - `DESCRIPTION` (если заполнено)
  - `UF_*` пользовательские поля (если есть)

### 5.2. Перенос в коробку
- Если в плане включено "переносить отделы":
  - создаём отделы в коробке через `CGroup::Add` (или аналог в зависимости от версии)
  - соблюдаем иерархию (сначала родители, потом дочки)
  - заполняем пользовательские поля, если определены
  - для каждого созданного отдела в Map сохраняем: cloudDepartmentId → localDepartmentId
- Если НЕ переносим отделы:
  - при привязке пользователей/сущностей используем дефолтный отдел коробки или отдел, указанный в настройках мигратора

### 5.3. Уникальность и конфликты
- Если отдел с таким названием уже есть в коробке (и он был там до миграции):
  - логируем это как WARNING
  - используем существующий отдел (не создаём дубль)
  - добавляем в Map маппинг: cloudDepartmentId → localDepartmentId
- Дедупликацию по названию можно контролировать через опцию в плане миграции: "переиспользовать существующие отделы" / "создавать новые"

## 6. Перенос пользователей
### 6.1. Маппинг и выявление новых
- В облаке: получаем список всех пользователей через `user.get` (с фильтром по статусу, если нужны только активные).
- В коробке: ищем соответствие:
  1) по email (точно, учитывая регистр)
  2) если не найден — по имени+фамилии (нечёткий поиск)
  3) если не найден — пользователь считается **новым**
- Результат: три группы:
  - "найдены точно" — маппируем, не переносим
  - "найдены неоднозначно" — логируем WARNING, ручная проверка в админке
  - "новые" — предлагаем для миграции в dry run

### 6.2. Выбор пользователей для миграции (в UI после dry run)
- Показываем список новых пользователей с полями:
  - ФИО
  - Email
  - Должность
  - Отдел (из облака)
  - Активный/неактивный
- Для каждого пользователя — чекбокс "мигрировать"
- Опции массового выбора: "мигрировать всех", "пропустить всех"
- Сохраняем выбор в State перед стартом миграции

### 6.3. Создание пользователя в коробке
Для каждого выбранного пользователя:
- Используем `CUser::Add` или REST API `user.add`
- Заполняем поля:
  - `NAME` (из облака)
  - `LAST_NAME` (из облака)
  - `EMAIL` (из облака)
  - `LOGIN` (из облака или генерируем, если недоступен)
  - `ACTIVE` (соответствует облаку; если выключен в облаке — выключаем и в коробке)
  - `PERSONAL_PHONE`, `PERSONAL_MOBILE`, `PERSONAL_PHOTO` (если заполнены в облаке)
  - `WORK_PHONE`, `WORK_POSITION`, `UF_*` (по доступным полям)
- Привязываем к отделу:
  - если отдел перенесён в коробку → используем localDepartmentId из Map
  - иначе → используем дефолтный отдел или отдел из настроек
- **Не отправляем** почтовые уведомления о регистрации (флаг `SKIP_SEND_NOTIFICATION` или эквивалент)
- Сохраняем маппинг в Map: cloudUserId → localUserId

### 6.4. Пользователи без email
- Если email в облаке не заполнен:
  - генерируем уникальный email: `migrator_user_<cloud_id>@invalid.local`
  - логируем WARNING с ФИО пользователя
  - создаём пользователя с генерированным email

### 6.5. Специальные пользователи
- Если в облаке есть "служебные" пользователи (система, робот, etc):
  - по умолчанию НЕ включаем их в список для миграции
  - но можно вручную выбрать в UI, если нужно

## 7. Пользователи (маппинг и заглушки в CRM)
### 7.1. Поиск пользователей для привязки к CRM сущностям
- Для каждого поля типа "пользователь" в сущности (например `ASSIGNED_BY_ID`):
  - если это cloudUserId, ищем localUserId в Map
  - если найдено — используем local ID
  - если не найдено:
    - если пользователь был отклонен при миграции → используем дефолтного пользователя (из настроек или текущего админа)
    - логируем WARNING

### 7.2. Создание "уволенного" пользователя-заглушки (только если не было миграции пользователей)
- Этот механизм используется **только** если **не** мигрируем пользователей (т.е. опция отключена в плане).
- Если пользователя не нашли и это cloudUserId, который не был перенесён:
  - создаём "заглушку" — неактивного пользователя в коробке
  - пользователь должен быть "уволенным" (неактивным): `ACTIVE = 'N'`
  - пользователь должен быть в дефолтных группах "как у обычного сотрудника" (берём группы из настроек мигратора)
  - EMAIL/LOGIN берём из облака; если email недоступен — генерируем уникальный email (`migrator_ghost_<n>@invalid.local`)
  - **не отправляем** почтовых уведомлений о регистрации
  - отдел не указываем (попадёт в первый по умолчанию — далее руками можно переместить)
  - сохраняем маппинг: cloudUserId → localUserId (заглушки)

## 8. Рабочие группы (Workgroups/Проекты) — НОВОЕ!
### 8.1. Типы видимости
- **Public** (открытая): VISIBLE = 'Y' — видят все, может присоединиться любой
- **Private** (приватная): VISIBLE = 'L' — видят все, присоединение по приглашению/запросу
- **Secret** (секретная): VISIBLE = 'N' — невидима, доступ только по приглашению

### 8.2. Получение групп из облака
- Используем `socialnetwork.api.workgroup.list` для получения всех групп
- Для каждой группы собираем:
  - `ID` (cloudGroupId)
  - `NAME`
  - `DESCRIPTION`
  - `VISIBLE` (тип видимости)
  - `PARENT_ID` (если есть подгруппы)
  - `OWNER_ID` (владелец)
  - `UF_*` пользовательские поля (если есть)
- Используем `sonet_group.user.list` для получения членов каждой группы и их ролей

### 8.3. Создание групп в коробке
- Если в плане включено "переносить рабочие группы":
  - Сортируем группы по иерархии (родители → дочки)
  - Для каждой группы:
    - маппируем owner (cloudUserId → localUserId)
    - если владелец не мигрировал → используем администратора (логируем WARNING)
    - создаём группу через `\Bitrix\Socialnetwork\Workgroup::create` с параметрами:
      - `NAME`
      - `DESCRIPTION`
      - `VISIBLE` (Y/L/N)
      - `OWNER_ID` (маппированный)
      - `PARENT_ID` (если есть, маппированный из Map)
      - `UF_*` (если определены)
    - сохраняем маппинг в Map: cloudGroupId → localGroupId

### 8.4. Добавление членов в группы
- Для каждого члена группы:
  - маппируем пользователя (cloudUserId → localUserId)
  - если пользователь не найден — логируем WARNING и пропускаем
  - если пользователь найден:
    - добавляем его в группу через `CUserGroupBinding::add`
    - если роль != 'member', устанавливаем роль (moderator/owner) если API позволяет

### 8.5. Обработка иерархии групп
- Иерархия обрабатывается через DEPENDS_ON в очереди задач:
  - родительские группы создаются с приоритетом выше
  - дочерние группы зависят от создания родителя (DEPENDS_ON указывает на task ID родителя)
  - агент проверяет зависимости перед обработкой: если родитель не готов → задача откладывается в конец очереди

### 8.6. Уникальность и конфликты
- Если группа с таким названием уже есть в коробке (без `UF_CLOUD_ID`):
  - логируем WARNING
  - НЕ трогаем существующую группу (skip)
  - создаём новую группу с добавкой к имени (например "_migrated")
- Если найдена группа с `UF_CLOUD_ID` (повторный прогон):
  - применяем политику из настроек (SKIP / UPDATE / DELETE_AND_RECREATE / DUPLICATE)

## 9. Воронки и стадии сделок — НОВОЕ!
### 9.1. Получение воронок из облака
- Используем `crm.dealcategory.list` для получения всех воронок (pipelines)
- Для каждой воронки собираем:
  - `ID` (cloudCategoryId)
  - `NAME`
  - `SORT`
- Используем методы получения стадий для каждой категории, чтобы собрать:
  - `ID` (cloudStageId)
  - `CATEGORY_ID`
  - `NAME`
  - `SORT`

### 9.2. Создание воронок в коробке
- Если в плане включено "переносить воронки":
  - Для каждой выбранной воронки:
    - проверяем, существует ли воронка с тем же именем в коробке
    - если существует (и не имеет `UF_CLOUD_ID`) → используем существующую, логируем INFO
    - если не существует → создаём новую воронку с параметрами из облака
    - сохраняем маппинг: cloudCategoryId → localCategoryId
  - Для каждой стадии:
    - проверяем, существует ли стадия в соответствующей воронке
    - если существует (и не имеет `UF_CLOUD_ID`) → используем существующую, логируем INFO
    - если не существует → создаём новую стадию
    - сохраняем маппинг: cloudStageId → localStageId

### 9.3. Использование маппинга при миграции сделок
- При миграции сделки используем маппинг:
  - если сделка имеет cloudCategoryId → ищем localCategoryId в Map
  - если сделка имеет cloudStageId → ищем localStageId в Map
  - используем маппированные ID при создании/обновлении сделки в коробке

## 10. Пользовательские поля (UF_*)
### 10.1. Получение схемы полей из облака
- Для каждой сущности (deal, lead, contact, company) используем:
  - `crm.deal.fields()` и т.д. для получения списка всех полей (стандартных и UF_*)
  - `crm.deal.userfield.list()` и т.д. для получения детальной информации о пользовательских полях
- Собираем информацию:
  - `FIELD_NAME` (например, `UF_CRM_123`)
  - `TYPE` (string, int, date, select, etc.)
  - `TITLE` (название для пользователя)
  - `IS_REQUIRED`
  - `MULTIPLE` (если многозначное)
  - `LIST_ID` (если select — ID списка)
  - `VALUES` (если select — значения списка)

### 10.2. Создание полей в коробке
- Если в плане включено "переносить пользовательские поля" для сущности:
  - перед миграцией сущностей проверяем, существуют ли поля в коробке
  - если поля не существуют — создаём их через:
    - `crm.*.userfield.add` (REST API) или
    - `\Bitrix\Crm\UserFieldTable::add` (ORM)
  - заполняем параметры: TYPE, TITLE, IS_REQUIRED, MULTIPLE, LIST_ID и т.д.
  - **сохраняем маппинг**: cloudFieldName → localFieldName (обычно совпадают, но могут быть конфликты имён)

### 10.3. Исключение полей
- После dry run можно исключить определённые поля из переноса (чекбоксы в UI):
  - если поле исключено — не переносим его и его значения
  - логируем INFO о пропуске поля

## 11. Миграция CRM сущностей (Компании → Контакты → Лиды → Сделки)
### 11.1. Общий порядок (зависимости)
```
1. Компании (никоим образом не зависят от других)
2. Контакты (могут быть привязаны к компаниям, но могут быть и независимыми)
3. Лиды (могут быть привязаны к контактам/компаниям, но могут быть и независимыми)
4. Сделки (должны быть привязаны к лидам/контактам/компаниям)
```

### 11.2. Процесс миграции сущности (на примере сделки)
Для каждой сущности:
1. Получить данные из облака через REST API (например `crm.deal.list`)
2. Для каждого элемента:
   - проверить, существует ли в коробке (по `UF_CLOUD_ID`)
   - если существует и политика SKIP → пропустить
   - если существует и политика UPDATE/DELETE_AND_RECREATE → обновить/пересоздать
   - если не существует → создать
3. При создании/обновлении:
   - маппировать все связанные пользователей (ASSIGNED_BY_ID, CREATED_BY_ID, etc.)
   - маппировать всех связанные компании/контакты/лиды (через Map)
   - маппировать стадии сделок (если применимо)
   - для каждого пользовательского поля:
     - если поле есть в коробке (по маппингу) → заполнить значение
     - если поля нет → пропустить
     - если значение требует маппинга (например, select-значение) → маппировать
4. Сохранить маппинг: cloudId → localId в Map

### 11.3. Маппинг типов полей
Особые случаи при маппировании значений пользовательских полей:
- **Select-поле**: если значение содержит ID опции из облака → маппировать на локальный ID опции
- **Поле типа "пользователь"**: маппировать cloudUserId → localUserId
- **Поле типа "компания/контакт/лид"**: маппировать cloudId → localId через Map
- **Дата**: транспортировать как есть (формат ISO 8601)
- **Число**: транспортировать как есть
- **Строка**: транспортировать как есть

## 12. Связи между сущностями — НОВОЕ!
### 12.1. Типы связей в Bitrix24
- Контакты ↔ Компании (many-to-many, через `crm.contact.company.items.set`)
- Лиды ↔ Контакты (many-to-one обычно, через связи в сделке или прямые связи)
- Лиды ↔ Компании (many-to-many обычно)
- Сделки ↔ Лиды (many-to-one, через `LEAD_ID` в сделке)
- Сделки ↔ Контакты (many-to-many, через `crm.deal.contact.items.set`)
- Сделки ↔ Компании (many-to-one, через `COMPANY_ID` в сделке)
- Задачи ↔ CRM сущности (многие-к-одному)

### 12.2. Процесс восстановления связей
- После того, как все сущности созданы:
  1. Для каждой сделки в облаке:
     - получить связанные контакты (если есть)
     - маппировать cloudContactId → localContactId
     - установить связи в коробке через `crm.deal.contact.items.set`
  2. Для каждого контакта в облаке:
     - получить связанные компании
     - маппировать cloudCompanyId → localCompanyId
     - установить связи в коробке через `crm.contact.company.items.set`
  3. Для каждого лида в облаке:
     - получить связанные контакты/компании (если есть)
     - маппировать ID
     - установить связи в коробке (если API позволяет)

### 12.3. Логирование ошибок при связях
- Если не удалось найти маппированный ID при установке связи:
  - логируем WARNING (связь будет пропущена)
  - продолжаем миграцию

## 13. Таймлайн и активности — НОВОЕ!
### 13.1. Типы событий таймлайна
- История изменений (кто изменил, что изменилось)
- Комментарии (comments)
- Встречи (meetings) и звонки (calls)
- Email-переписка (если доступна)
- Документы (если прикреплены)

### 13.2. Получение таймлайна из облака
- Использовать `crm.activity.list()` или `crm.timeline.list()` (в зависимости от версии API)
- Для каждого события собрать:
  - `ID` (cloudActivityId)
  - `ENTITY_TYPE` и `ENTITY_ID` (к чему привязано событие: deal, lead, contact, company)
  - `TYPE_NAME` (тип события)
  - `CREATED_TIME`
  - `CREATED_BY` (пользователь)
  - `SUBJECT` (если есть)
  - `DESCRIPTION` (если есть)
  - `ATTACHMENTS` (если есть файлы)

### 13.3. Перенос таймлайна в коробку
- Если в плане включено "переносить таймлайн":
  1. маппировать ENTITY_ID (cloudEntityId → localEntityId) через Map
  2. маппировать CREATED_BY (cloudUserId → localUserId)
  3. создать событие в коробке через REST API или ORM в зависимости от типа события
  4. сохранить маппинг: cloudActivityId → localActivityId

### 13.4. Ограничения
- Не все события могут быть перенесены через REST API
- Email-переписка может быть недоступна
- Комментарии переносятся, но может потребоваться специальная обработка
- Логируем все ошибки и неподдерживаемые типы событий

## 14. Задачи
### 14.1. Получение задач из облака
- Использовать `tasks.task.list()` с фильтром по родительским сущностям (deal, lead, contact, company, workgroup)
- Для каждой задачи собрать:
  - `ID` (cloudTaskId)
  - `TITLE`
  - `DESCRIPTION`
  - `RESPONSIBLE_ID` (ответственный)
  - `CREATED_BY` (создатель)
  - `PARENT_ID` (если подзадача)
  - `PARENT_ENTITY_TYPE` и `PARENT_ENTITY_ID` (к чему привязана)
  - `DEADLINE`
  - `STATUS`
  - `PRIORITY`
  - `CHECKLIST` (если есть)
  - `COMMENTS` (если нужно перенести)
  - `ATTACHMENTS` (если нужно перенести файлы)
  - `UF_*` (пользовательские поля)

### 14.2. Перенос задач в коробку
- Если в плане включено "переносить задачи":
  1. сортировать задачи по иерархии (parent → children)
  2. маппировать все ID (RESPONSIBLE_ID, CREATED_BY, PARENT_ENTITY_ID, PARENT_ID)
  3. создать задачу в коробке через REST API (`tasks.task.add`) или ORM
  4. перенести чек-листы (если есть)
  5. перенести комментарии (если включено в плане)
  6. перенести файлы (если включено в плане)
  7. сохранить маппинг: cloudTaskId → localTaskId

### 14.3. Связи задач с сущностями
- При миграции задач маппировать привязки:
  - если задача привязана к сделке → маппировать cloudDealId → localDealId
  - если задача привязана к лиду → маппировать cloudLeadId → localLeadId
  - если задача привязана к контакту → маппировать cloudContactId → localContactId
  - если задача привязана к компании → маппировать cloudCompanyId → localCompanyId
  - если задача привязана к рабочей группе → маппировать cloudGroupId → localGroupId

## 15. Хранилище данных (HL-блоки)
Создаём минимум 6 HL-блоков:

### 15.1. MigratorState (состояние миграции)
Назначение:
- хранить настройки подключения (кроме секрета), выбранные чекбоксы плана, текущую фазу, прогресс, флаг pause, режимы повторного прогона и т.п.

Пример полей:
- UF_STATUS: NEW / DRY_RUN_DONE / RUNNING / PAUSED / FINISHED / ERROR
- UF_CURRENT_PHASE: string
- UF_PAUSE_FLAG: boolean
- UF_SETTINGS_JSON: string (или text) — сериализованный план/настройки (включает: какие пользователи мигрируются, переносится ли структура, и т.д.)
- UF_LAST_ERROR: text
- UF_STARTED_AT, UF_UPDATED_AT

### 15.2. MigratorQueue (очередь работ)
Назначение:
- разложить миграцию на атомарные задачи, чтобы агент мог шагать, продолжать после падений, и было видно прогресс.

Пример полей:
- UF_ENTITY_TYPE: department / user / workgroup / disk_folder / disk_file / dealcategory / deal / lead / contact / company / task / activity / file / ...
- UF_CLOUD_ID: int/string
- UF_LOCAL_ID: int (если уже создан)
- UF_STATUS: NEW / IN_PROGRESS / DONE / ERROR / SKIPPED
- UF_RETRIES: int
- UF_LAST_ERROR: text
- UF_PRIORITY: int
- UF_DEPENDS_ON: int (опционально: ID другой task в очереди, если зависит от другой)
- UF_UPDATED_AT

### 15.3. MigratorMap (маппинг идентификаторов)
Назначение:
- хранить соответствие cloud → local по сущностям, пользователям, файлам, отделам и т.д.

Пример полей:
- UF_ENTITY_TYPE: department / user / workgroup / disk_folder / disk_file / dealcategory / dealstage / deal / lead / contact / company / task / activity / file / ...
- UF_CLOUD_ID
- UF_LOCAL_ID
- UF_CLOUD_URL (опционально)
- UF_META_JSON (опционально)

### 15.4. MigratorLog (журнал)
Назначение:
- понятные логи для админа и разработчика.

Пример полей:
- UF_LEVEL: INFO/WARN/ERROR/DEBUG
- UF_MESSAGE: text
- UF_CONTEXT: string (phase/entity/id)
- UF_PAYLOAD: text/json (безопасно, без секретов)
- UF_CREATED_AT

### 15.5. MigratorDryRunResult (результаты last dry run)
Назначение:
- сохранять результаты последнего dry run для отображения в UI и для базы выбора при формировании плана.

Пример полей:
- UF_DEPARTMENTS_COUNT: int
- UF_USERS_COUNT: int
- UF_USERS_NEW_COUNT: int
- UF_USERS_NEW_LIST: text/json (список новых пользователей с их данными)
- UF_WORKGROUPS_COUNT: int
- UF_WORKGROUPS_BY_TYPE: text/json (public/private/secret counts)
- UF_WORKGROUPS_TREE: text/json (иерархия)
- UF_DISK_ESTIMATE: text/json (оценка количества/объёма, если доступно)
- UF_DEALS_COUNT: int
- UF_LEADS_COUNT: int
- UF_CONTACTS_COUNT: int
- UF_COMPANIES_COUNT: int
- UF_PIPELINES: text/json (список воронок и стадий)
- UF_CUSTOM_FIELDS: text/json (список пользовательских полей)
- UF_EXECUTED_AT
- UF_WEBHOOK_STATUS: OK / ERROR
- UF_WEBHOOK_ERROR_MSG: text (если ошибка)

### 15.6. MigratorWorkgroupMap (маппинг рабочих групп) — НОВОЕ!
Назначение:
- специализированное хранилище для маппинга рабочих групп с их метаданными (parent, type, owner).

Пример полей:
- UF_CLOUD_ID: string (ID группы в облаке)
- UF_LOCAL_ID: int (ID в коробке)
- UF_PARENT_ID: int (ID родительской группы в коробке, если есть)
- UF_TYPE: string (public/private/secret)
- UF_OWNER_ID: int (ID владельца в коробке)
- UF_CLOUD_URL: string (ссылка на облако)
- UF_META_JSON: text (дополнительные метаданные)

## 16. Стратегия по диску и файлам (коробка) — ОБНОВЛЕНО

### 16.1. Режимы переноса
- `NONE` — не переносим диск и файлы.
- `ATTACHMENTS_ONLY` — переносим только файлы, встречающиеся как вложения (таймлайн/задачи/карточки).
- `FULL_DISK` — переносим весь диск: **структура папок + файлы**, без прав/шаринга.

### 16.2. Общие принципы
- Все файлы сначала выгружаются в папку на **общем диске** (одна корневая папка миграции).
- Копии файлов допустимы (дедупликацию можно сделать позже).
- Права доступа и шаринг **не переносим** (всё создаётся под техническим пользователем/админом).

### 16.3. Структура хранения (для вложений)
Базовая структура хранения:
- `Migrator/Deals/<cloudDealId>/...`
- `Migrator/Leads/<cloudLeadId>/...`
- `Migrator/Contacts/<cloudContactId>/...`
- `Migrator/Companies/<cloudCompanyId>/...`
- `Migrator/Tasks/<cloudTaskId>/...`
- `Migrator/Workgroups/<cloudGroupId>/...`
- `Migrator/Timeline/<cloudEntityType>/<cloudEntityId>/...`

### 16.4. Структура хранения (для FULL_DISK)
- Корневая папка: `Migrator/Disk/`
- Внутри создаём структуру папок, соответствующую источнику, и загружаем файлы.

## 17. Ссылки и cloud_id в коробке
Для каждой переносимой сущности создаём (если отсутствуют) системные пользовательские поля:
- `UF_CLOUD_ID` (число/строка)
- `UF_CLOUD_URL` (строка)

Далее все связи строим не по "сырым ID из облака", а через Map:
- если поле "привязка к компании" в сделке содержит cloudCompanyId → ищем localCompanyId по UF_CLOUD_ID/Map и ставим local ID.

## 18. Очерёдность (pipeline) миграции — ОБНОВЛЕННАЯ
Фазы (с возможностью паузы между шагами):

1. **Dry run**: сбор структуры, пользователей, рабочих групп, диска, воронок, CRM данных и формирование плана (без записи данных, кроме результатов в HL-блок)

2. **Подготовка коробки**:
   - создание пользовательских полей (по выбранному плану)
   - создание воронок/стадий сделок (по выбранному плану)
   - создание необходимых HL-блоков (MigratorState, MigratorQueue, MigratorMap, MigratorLog, MigratorDryRunResult, MigratorWorkgroupMap)

3. **Перенос структуры (отделы)**:
   - если включено в плане — создание отделов с соблюдением иерархии
   - маппинг в MigratorMap

4. **Перенос пользователей**:
   - если включено в плане — создание выбранных пользователей
   - маппинг в MigratorMap

5. **Перенос рабочих групп**:
   - если включено в плане — создание групп с соблюдением иерархии (DEPENDS_ON для parent → children)
   - добавление членов группы с маппингом пользователей
   - маппинг в MigratorMap и MigratorWorkgroupMap

6. **Перенос диска (Disk)**:
   - если включено в плане — перенос структуры папок и файлов в выбранном режиме
   - маппинг в MigratorMap

7. **Перенос базовых сущностей CRM**:
   - компании
   - контакты (с привязкой к компаниям и пользователям)
   - лиды (с привязкой к пользователям)
   - сделки (с привязками к контактам/компаниям/лидам/пользователям/воронкам/стадиям, где применимо)

8. **Восстановление связей между сущностями**:
   - контакты ↔ компании
   - лиды ↔ контакты
   - лиды ↔ компании
   - сделки ↔ лиды
   - сделки ↔ контакты
   - сделки ↔ компании
   - задачи ↔ CRM сущности (во время миграции задач)

9. **Перенос задач**:
   - если включено в плане — создание задач с привязками к CRM сущностям и рабочим группам
   - перенос чек-листов, комментариев, файлов (если включено)
   - маппинг в MigratorMap

10. **Перенос таймлайна и активностей**:
   - история действий (Timeline)
   - комментарии (Comments)
   - встречи, звонки и другие события (Activity)
   - маппинг в MigratorMap

11. **Финализация**: отчёт, статистика, список проблем (пользователи/файлы/ошибки)

## 19. Исполнение (агент) и управление
- Выполнение через агент:
  - агент берёт пачку задач из Queue (с учётом приоритета и зависимостей DEPENDS_ON)
  - проверяет DEPENDS_ON: если зависимость не выполнена → откладывает задачу в конец очереди
  - обрабатывает шаг
  - фиксирует прогресс в State/Queue/Map/Log
  - проверяет флаг PAUSE → завершает текущий шаг и выходит
- Управление:
  - Start: создаёт план очереди (с учётом выбранных пользователей, групп и структуры) и включает RUNNING
  - Pause: выставляет флаг PAUSE (graceful stop)
  - Resume: снимает флаг PAUSE и продолжает по чекпойнту

## 20. UI админки (одна страница с табами)
Одна страница модуля в стиле админки Битрикса, табы:
- **Подключение** (webhook, проверки, кнопка Dry run)
- **Dry run** (отчёт с информацией о структуре/пользователях/рабочих группах/диске/воронках/CRM, кнопка "Сформировать план")
- **План миграции**:
  - Структура: чекбокс "переносить отделы", выбор дефолтного отдела (если не мигрируем)
  - Пользователи: список новых с чекбоксами, "выбрать всех" / "пропустить всех", выбор группы по умолчанию
  - Рабочие группы: чекбокс "переносить рабочие группы", опция "переносить иерархию", опция "переносить права доступа"
  - Диск: режим `FULL_DISK` / `ATTACHMENTS_ONLY` / `NONE`, ограничения (опционально)
  - Воронки: список воронок с чекбоксами, опция "переносить все"
  - CRM сущности: чекбоксы "что переносим" (компании, контакты, лиды, сделки)
  - Исключения полей по сущностям
  - Политика повторного прогона по UF_CLOUD_ID
  - Опция "переносить таймлайн"
  - Опция "переносить задачи"
  - Кнопка "Запустить миграцию"
- **Миграция** (старт/пауза/продолжить, прогресс по фазам, счётчики, статус каждой фазы)
- **Логи** (фильтры уровней, экспорт, очистка)

## 21. Открытые вопросы (фиксируем заранее)
- Полный перечень типов событий таймлайна, которые реально можно перенести через REST API облака
- Как обрабатывать файлы, привязанные через CRM API (нужны ли дополнительные права на скачивание)
- Лимиты на количество одновременных запросов к облаку (throttling)
- Минимальная версия коробки, поддерживающая все используемые API методы
- Необходимость поддержки шифрования секретов в HL-блоках (webhook token)
- API методы для работы с правами доступа в рабочих группах (если нужна поддержка)
- API методы для перехвата событий при создании сущностей (для асинхронного логирования)
- FULL_DISK: перечень методов Disk API, необходимых для обхода структуры и скачивания (уточнить по доступности)
