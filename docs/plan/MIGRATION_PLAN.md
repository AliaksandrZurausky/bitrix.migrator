# Bitrix Migrator — план миграции (Cloud → Box)

## 0. Цель и принципы
- Цель: разовая миграция данных из облачного Bitrix24 в коробочный Bitrix (CRM сущности + связи + таймлайн + задачи + файлы) без удаления данных в облаке.
- Основной принцип: миграция асинхронная, управляемая (start/pause/resume), не привязанная к сессии браузера.
- Основной принцип идемпотентности: повторный запуск после паузы/сбоя НЕ создаёт дублей, если элемент уже был перенесён мигратором и имеет `UF_CLOUD_ID`.

## 1. Источник данных (облако)
- Источник: REST API Bitrix24 через входящий webhook вида `https://<portal>/rest/<user>/<token>/...`.
- Получение структуры полей сущностей через методы `crm.*.fields` (например `crm.deal.fields`) для dry run и построения плана переноса.
- Для пользовательских полей (если потребуется точечное создание) ориентироваться на семейство методов `crm.*.userfield.*` (например `crm.deal.userfield.add`).

## 2. Сущности в MVP
Обязательные к переносу:
- Сделки
- Лиды
- Контакты
- Компании

Также требуется (как зависимости/содержимое):
- Таймлайн CRM (максимально возможный перенос)
- Задачи, связанные с CRM сущностями (переносить «всё что можно», лучше отдельной финальной фазой)
- Файлы из:
  - таймлайна
  - задач
  - карточек элементов (если прикреплены)

## 3. Политики “конфликтов” и повторного запуска
### 3.1. “Чистая система”
- Предполагаем, что коробка чистая: если встречается сущность без `UF_CLOUD_ID`, мы её **не трогаем** (skip) и пишем в лог.

### 3.2. “Элемент уже переносился мигратором”
- Если в коробке найден объект с заполненным `UF_CLOUD_ID`, то это “повторный прогон”, и поведение определяется настройкой перед запуском миграции:
  - `SKIP` (по умолчанию)
  - `UPDATE` (обновлять поля по данным из облака)
  - `DELETE_AND_RECREATE` (удалить и создать заново)
  - `DUPLICATE` (создать дубль, сохранив старый)
- Настройка задаётся **после dry run**, перед стартом миграции, и сохраняется в State HL-блоке.

## 4. Dry run (обязательный шаг перед миграцией)
Dry run выполняет:
- Проверку подключения к webhook и прав доступа.
- Сбор справочных данных (что доступно для переноса).
- Формирование “плана миграции” (по умолчанию включено всё).

### 4.1. Что должно быть доступно для выбора (в UI)
После dry run, до “Старт миграции” должно быть UI, где по умолчанию всё включено, но можно отключить:
- Сущности: сделки/лиды/контакты/компании
- Воронки/направления сделок + стадии (выбрать, какие переносим)
- Пользовательские поля по каждой сущности (чекбоксы исключения полей)
- Таймлайн: типы событий (если удастся классифицировать)
- Задачи: чекбоксы “переносить комментарии / чек-листы / файлы / …” (если API позволит)
- Файлы: чекбоксы “качать/загружать”, ограничения по размеру/типам (опционально)

### 4.2. Результаты dry run (отчёт)
- Количество сущностей к переносу по типам.
- Найденные воронки/стадии сделок (и возможность выбрать какие переносить).
- Список пользовательских полей по каждой сущности (и возможность снять галочки).
- Оценка по файлам (кол-во, примерные объёмы если возможно).
- Отчёт по пользователям:
  - сколько пользователей нашли однозначно
  - сколько “не нашли/неоднозначно” → будет создана заглушка

## 5. Пользователи (маппинг и заглушки)
### 5.1. Поиск пользователей
- В облаке: искать пользователей можно через `user.search` (по персональным данным, в т.ч. ФИО).
- В коробке: матчинг делаем:
  1) по email (точно),
  2) если не найден — по имени+фамилии.
- Матчинг выполняется среди всех пользователей (включая неактивных/уволенных).

### 5.2. Создание “уволенного” пользователя-заглушки
- Если пользователя не нашли или нашли неоднозначно:
  - создаём пользователя в коробке через `CUser::Add`.
  - пользователь должен быть “уволенным” (неактивным): `ACTIVE = 'N'`.
  - пользователь должен быть в дефолтных группах “как у обычного сотрудника” (берём группы из настроек мигратора, чтобы не хардкодить).
  - EMAIL/LOGIN берём из облака; если вдруг email недоступен — генерируем уникальный email по нумератору (например `migrator_ghost_<n>@invalid.local`), и **не отправляем почтовых уведомлений** о регистрации.
  - отдел не указываем (попадёт в первый по умолчанию — далее руками можно переместить).

## 6. Хранилище данных (HL-блоки)
Создаём минимум 4 HL-блока:

### 6.1. MigratorState (состояние миграции)
Назначение:
- хранить настройки подключения (кроме секрета), выбранные чекбоксы плана, текущую фазу, прогресс, флаг pause, режимы повторного прогона и т.п.

Пример полей:
- UF_STATUS: NEW / DRY_RUN_DONE / RUNNING / PAUSED / FINISHED / ERROR
- UF_CURRENT_PHASE: string
- UF_PAUSE_FLAG: boolean
- UF_SETTINGS_JSON: string (или text) — сериализованный план/настройки
- UF_LAST_ERROR: text
- UF_STARTED_AT, UF_UPDATED_AT

### 6.2. MigratorQueue (очередь работ)
Назначение:
- разложить миграцию на атомарные задачи, чтобы агент мог шагать, продолжать после падений, и было видно прогресс.

Пример полей:
- UF_ENTITY_TYPE: deal/lead/contact/company/task/file/...
- UF_CLOUD_ID: int/string
- UF_LOCAL_ID: int (если уже создан)
- UF_STATUS: NEW / IN_PROGRESS / DONE / ERROR / SKIPPED
- UF_RETRIES: int
- UF_LAST_ERROR: text
- UF_PRIORITY: int
- UF_DEPENDS_ON: string (опционально: зависимости)
- UF_UPDATED_AT

### 6.3. MigratorMap (маппинг идентификаторов)
Назначение:
- хранить соответствие cloud → local по сущностям, пользователям, файлам и т.д.

Пример полей:
- UF_ENTITY_TYPE
- UF_CLOUD_ID
- UF_LOCAL_ID
- UF_CLOUD_URL (опционально)
- UF_META_JSON (опционально)

### 6.4. MigratorLog (журнал)
Назначение:
- понятные логи для админа и разработчика.

Пример полей:
- UF_LEVEL: INFO/WARN/ERROR/DEBUG
- UF_MESSAGE: text
- UF_CONTEXT: string (phase/entity/id)
- UF_PAYLOAD: text/json (безопасно, без секретов)
- UF_CREATED_AT

## 7. Стратегия по файлам (коробка)
- Все файлы сначала выгружаются в папку на **общем диске** (одна корневая папка миграции).
- Копии файлов допустимы (дедупликацию можно сделать позже).
- Структура хранения (базовая):
  - `Migrator/Deals/<cloudDealId>/...`
  - `Migrator/Leads/<cloudLeadId>/...`
  - `Migrator/Contacts/<cloudContactId>/...`
  - `Migrator/Companies/<cloudCompanyId>/...`
  - `Migrator/Tasks/<cloudTaskId>/...`

## 8. Ссылки и cloud_id в коробке
Для каждой переносимой сущности создаём (если отсутствуют) системные пользовательские поля:
- `UF_CLOUD_ID` (число/строка)
- `UF_CLOUD_URL` (строка)

Далее все связи строим не по “сырым ID из облака”, а через Map:
- если поле “привязка к компании” в сделке содержит cloudCompanyId → ищем localCompanyId по UF_CLOUD_ID/Map и ставим local ID.

## 9. Очерёдность (pipeline) миграции
Фазы (с возможностью паузы между шагами):
1) Dry run: сбор структуры и формирование плана (без записи данных)
2) Подготовка коробки:
   - создание пользовательских полей (по выбранному плану)
   - создание воронок/стадий сделок (по выбранному плану)
3) Перенос справочников/зависимостей (если всплывут)
4) Перенос базовых сущностей:
   - компании
   - контакты (с привязкой к компаниям)
   - лиды
   - сделки (с привязками к контактам/компаниям/лидам, где применимо)
5) Перенос таймлайна (насколько возможно)
6) Перенос задач, связанных с CRM сущностями (в конце, чтобы привязки уже были)
7) Перенос/прикрепление файлов (если не сделали в процессе сущностей/таймлайна/задач)
8) Финализация: отчёт, статистика, список проблем (пользователи/файлы/ошибки)

## 10. Исполнение (агент) и управление
- Выполнение через агент:
  - агент берёт пачку задач из Queue
  - обрабатывает шаг
  - фиксирует прогресс в State/Queue/Map
  - проверяет флаг PAUSE → завершает текущий шаг и выходит
- Управление:
  - Start: создаёт план очереди и включает RUNNING
  - Pause: выставляет флаг PAUSE (graceful stop)
  - Resume: снимает флаг PAUSE и продолжает по чекпойнту

## 11. UI админки (одна страница с табами)
Одна страница модуля в стиле админки Битрикса, табы:
- Подключение (webhook, проверки, кнопка Dry run)
- Dry run (отчёт + кнопка “Сформировать план”)
- План миграции (чекбоксы “что переносим”, исключения полей, выбор воронок, политика повторного прогона по UF_CLOUD_ID)
- Миграция (старт/пауза/продолжить, прогресс по фазам, счётчики)
- Логи (фильтры уровней, экспорт, очистка)

## 12. Открытые вопросы (фиксируем заранее)
- Полный перечень типов событий таймлайна, которые реально можно перенести в коробку 1:1 (возможно, часть будет через комментарии/активности).
- Полный перечень того, что “можно перенести по задачам” (комментарии/чек-листы/файлы/участники/статусы) — определить по доступности методов API в текущем облаке.
